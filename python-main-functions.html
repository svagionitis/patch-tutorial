
<html>
    <head>
        <style>
            .diff_old {
                background-color: #FFCCCC;
                text-decoration: line-through;
            }
            .diff_new {
                background-color: #CCFFCC;
                font-weight:bold; }
            .filename {
                text-align: center;
                padding: 0.3em;
                margin: 0;
                border-bottom: solid thin black;
                font-family: sans-serif;
                font-size: small;
            }
            .show {
                margin: 0;
            }
            .diff {
                margin: 0;
            }
            .file_container {
                margin: 1em 3em 1em 3em;
            }
            .hunk_header {
                font-family: sans-serif;
                font-size: x-small;
                padding: 0 0 0 3em;
                background-color: #F0F0F0;
            }
        </style>
        <script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/solarized_light.min.css"/>
    </head>
    <body>
<h1>Python <code>main()</code> functions</h1>
<h3>By Guido van van Rossum</h3>
<h4>May 15, 2003</h4>
<blockquote>
<h2>Summary</h2>
<p>For Python programmers, I've got some suggestions on how to write a
main() function that's easy to invoke in other contexts, e.g. from the
interactive Python prompt when you feel like experimenting.</p>
</blockquote>
<hr />
<p>I've written a few <code>main()</code> functions in my time. They usually have a structure roughly like this:</p>
<div class="file_container">
<div class="filename">main.py</div>
<pre class="show"><code>#!/usr/bin/env python
"""Module docstring.

This serves as a long usage message.
"""
import sys
import getopt

def main():
    # parse command line options
    try:
        opts, args = getopt.getopt(sys.argv[1:], "h", ["help"])
    except getopt.error, msg:
        print msg
        print "for help use --help"
        sys.exit(2)
    # process options
    for o, a in opts:
        if o in ("-h", "--help"):
            print __doc__
            sys.exit(0)
    # process arguments
    for arg in args:
        process(arg) # process() is defined elsewhere

if __name__ == "__main__":
    main()

</code></pre>
</div>
<p>I'm sure many people write similar <code>main()</code> functions. I've got a few
suggestions that make <code>main()</code> a little more flexible, especially as option
parsing becomes more complex.</p>
<p>First, we change <code>main()</code> to take an optional 'argv' argument, which allows us to call it from the interactive Python prompt:</p>
<div class="file_container">
<div class="filename">main.py</div>
<div class="hunk_header">line 6...</div>
<pre class="diff"><code><div class="diff_unchanged">import sys
</div><div class="diff_unchanged">import getopt
</div><div class="diff_unchanged">
</div><div class="diff_old">def main():
</div><div class="diff_new">def main(argv=None):
</div><div class="diff_new">    if argv is None:
</div><div class="diff_new">        argv = sys.argv
</div><div class="diff_unchanged">    # parse command line options
</div><div class="diff_unchanged">    try:
</div><div class="diff_old">        opts, args = getopt.getopt(sys.argv[1:], "h", ["help"])
</div><div class="diff_new">        opts, args = getopt.getopt(argv[1:], "h", ["help"])
</div><div class="diff_unchanged">    except getopt.error, msg:
</div><div class="diff_unchanged">        print msg
</div><div class="diff_unchanged">        print "for help use --help"
</div></code></pre>
</div>
<p>Note that we fill in the default for argv dynamically. This is more flexible
than writing</p>
<pre><code>def main(argv=sys.argv):
    # etc.
</code></pre>
<p>because <code>sys.argv</code> might have been changed by the time the call is made; the
default argument is calculated at the time the <code>main()</code> function is defined,
for all times.</p>
<p>Now the <code>sys.exit()</code> calls are annoying: when <code>main()</code> calls <code>sys.exit()</code>, your interactive Python interpreter will exit! The remedy is to let <code>main()</code>'s return value specify the exit status. Thus, the code becomes</p>
<div class="file_container">
<div class="filename">main.py</div>
<div class="hunk_header">line 15...</div>
<pre class="diff"><code><div class="diff_unchanged">    except getopt.error, msg:
</div><div class="diff_unchanged">        print msg
</div><div class="diff_unchanged">        print "for help use --help"
</div><div class="diff_old">        sys.exit(2)
</div><div class="diff_new">        return 2
</div><div class="diff_unchanged">    # process options
</div><div class="diff_unchanged">    for o, a in opts:
</div><div class="diff_unchanged">        if o in ("-h", "--help"):
</div><div class="diff_unchanged">            print __doc__
</div><div class="diff_old">            sys.exit(0)
</div><div class="diff_new">            return 0
</div><div class="diff_unchanged">    # process arguments
</div><div class="diff_unchanged">    for arg in args:
</div><div class="diff_unchanged">        process(arg) # process() is defined elsewhere
</div><div class="diff_unchanged">
</div><div class="diff_unchanged">if __name__ == "__main__":
</div><div class="diff_old">    main()
</div><div class="diff_new">    sys.exit(main())
</div><div class="diff_unchanged">
</div></code></pre>
</div>
<p>and the calls to <code>sys.exit(n)</code> inside <code>main()</code> all become <code>return n</code>.</p>
<p>Another refinement is to define a <code>Usage()</code> exception, which we catch in an except clause at the end of <code>main()</code>:</p>
<div class="file_container">
<div class="filename">main.py</div>
<pre class="show"><code>#!/usr/bin/env python
"""Module docstring.

This serves as a long usage message.
"""
import sys
import getopt

class Usage(Exception):
    def __init__(self, msg):
        self.msg = msg

def main(argv=None):
    if argv is None:
        argv = sys.argv
    # parse command line options
    try:
        try:
            opts, args = getopt.getopt(argv[1:], "h", ["help"])
        except getopt.error, msg:
             raise Usage(msg)
        # more code, unchanged
    except Usage, err:
        print &gt;&gt;sys.stderr, err.msg
        print &gt;&gt;sys.stderr, "for help use --help"
        return 2

if __name__ == "__main__":
    sys.exit(main())

</code></pre>
</div>
<p>This gives the <code>main()</code> function a single exit point, which is preferable over
multiple <code>return 2</code> statements. This also makes it easier to refactor the
argument parsing: <code>raise Usage</code> works just fine from inside a helper function,
but <code>return 2</code> would require careful passing on of the return values.</p>
<p>You might think that taking this to the extreme would move the <code>try</code>/<code>except</code>
clause out of the <code>main()</code> function, into the code at the end of the module (if
<code>__name__ == "__main__": ....</code> But that would mean that when you call <code>main()</code>
interactively, you'd get a traceback for command line syntax errors, which
isn't very helpful.</p>
<p>However, another generalization can be helpful: define another exception,
perhaps called <code>Error</code>, which is treated just like <code>Usage</code> but <code>return</code>s <code>1</code>.
This can then be used for expected errors like failure to open necessary files,
which are not command line syntax errors, but yet expected, and where again a
traceback doesn't feel very friendly.</p>

    </body>
</html>
